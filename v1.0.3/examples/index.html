<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · WENDy.jl</title><meta name="title" content="Examples · WENDy.jl"/><meta property="og:title" content="Examples · WENDy.jl"/><meta property="twitter:title" content="Examples · WENDy.jl"/><meta name="description" content="Documentation for WENDy.jl."/><meta property="og:description" content="Documentation for WENDy.jl."/><meta property="twitter:description" content="Documentation for WENDy.jl."/><meta property="og:url" content="https://nrummel.github.io/WENDy.jl/examples/"/><meta property="twitter:url" content="https://nrummel.github.io/WENDy.jl/examples/"/><link rel="canonical" href="https://nrummel.github.io/WENDy.jl/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WENDy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingStarted/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Logistic-Growth"><span>Logistic Growth</span></a></li><li><a class="tocitem" href="#Goodwin"><span>Goodwin</span></a></li><li><a class="tocitem" href="#SIR"><span>SIR</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nrummel/WENDy.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Here we give three examples of ODE&#39;s and how to use WENDy to estimate the parameters. </p><h2 id="Logistic-Growth"><a class="docs-heading-anchor" href="#Logistic-Growth">Logistic Growth</a><a id="Logistic-Growth-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic-Growth" title="Permalink"></a></h2><p>The logistic growth equation is a well-known differential equation that has an exact solution. Classically, it was developed to describe population growth rate <span>$r$</span> with a carrying capacity <span>$K$</span>, <span>$\dot{u} = ru(1-\tfrac{u}{K})$</span>. We have reparameterized this equation to be amenable to optimization. </p><p class="math-container">\[\dot{u}=p_1 u+p_2 u^2\]</p><p>For the sake of the example we will generate data by numerically solving the ODE, and then corrupting with noise. We do this through the standard library and OrdinaryDiffEq.jl. </p><pre><code class="language-julia hljs">using Random, LinearAlgebra
using OrdinaryDiffEq: ODEProblem
using OrdinaryDiffEq: solve as solve_ode
using WENDy</code></pre><p>Now, we define the right hand side of the ODE, initial conditions, the time domain, and specify the true parameters:</p><pre><code class="language-julia hljs">function f!(du, u, p, t)
    du[1] = p[1] * u[1] - p[2] * u[1]^2
    nothing
end
tRng = (0.0, 10.0)
dt = 0.01
u₀ = [0.01]
pstar = [1.0, 1.0]
J = length(pstar)

ode = ODEProblem(
    f!,
    u₀,
    tRng,
    pstar
)
tt = tRng[1]:dt:tRng[end]
Ustar = reduce(vcat, um for um in solve_ode(ode, saveat=dt).u)
nr = 0.1 # noise ratio
U = Ustar + nr*randn(size(Ustar)) # corrupting the data with noise</code></pre><p>Now, that we have the data we are ready to build a WENDy Problem and then solve it. </p><pre><code class="language-julia hljs">wendyProb = WENDyProblem(
    tt,
    U,
    f!,
    J
)</code></pre><p>The algorithm requires an initial guess for the parameter values. From this initial guess, it will then approximate the maximum likelihood estimator.</p><pre><code class="language-julia hljs">p₀ = [0.5, 0.5]
@time phat = solve(wendyProb, p₀)
@show phat</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> 16.685811 seconds (36.01 M allocations: 1.843 GiB, 4.06% gc time, 98.70% compilation time)
phat = [1.024187891088431, 1.0207993570793095]</code></pre><p>The efficiency of the solver can be improved by specifying that the function <span>$f$</span> is linear in parameters. This is done with the optional argument to the WENDyProblem. </p><pre><code class="language-julia hljs">wendyProb_linear = WENDyProblem(
    tt,
    U,
    f!,
    J,
    linearInParameters=Val(true), # f! is linear in parameters
)
@time (wendyProb_linear, p₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  0.000008 seconds (3 allocations: 352 bytes)</code></pre><p>This problem can be visualized by looking at the data, the true solution of the ODE and the solution given by the estimated parameters.</p><pre><code class="language-julia hljs">using PlotlyJS
odeprob = ODEProblem(f!, u₀, tRng, phat)
sol = solve_ode(odeprob; saveat=dt)
Uhat = reduce(vcat, um&#39; for um in sol.u)
plot(
    [
        scatter(x=tt, y=U[:], name=&quot;data&quot;, mode=&quot;markers&quot;, marker_color=&quot;blue&quot;, marker_opacity=0.5),
        scatter(x=tt, y=Ustar[:], name=&quot;truth&quot;, line_color=&quot;blue&quot;, line_width=3),
        scatter(x=tt, y=Uhat[:], name=&quot;estimate&quot;, line_dash=&quot;dash&quot;, line_color=&quot;black&quot;, line_width=3),
    ],
    Layout(title=&quot;Logistic Growth&quot;,xaxis_title=&quot;time(s)&quot;, yaxis_title=&quot;u(t)&quot;)
)</code></pre><img src="7a067910.svg" alt="Example block output"/><h2 id="Goodwin"><a class="docs-heading-anchor" href="#Goodwin">Goodwin</a><a id="Goodwin-1"></a><a class="docs-heading-anchor-permalink" href="#Goodwin" title="Permalink"></a></h2><p>A simple example of a system of differential equations which is nonlinear in parameters is the Goodwin model which describes negative feedback control processes . In particular there is a Hill function in the equation for <span>$u_1$</span>. The parameter <span>$p_3$</span> appears in the denominator and <span>$p_4$</span> is the Hill coefficient, and thus this serves as an example of how nonlinearity can effect the performance of the WENDy algorithm. </p><p class="math-container">\[\begin{aligned}
    \dot{u}_1 &amp;= \frac{p_1}{2.15 + p_3 u_3^{p_4}} - p_2  u_1 \\
    \dot{u}_2 &amp;= p_5u_1- p_6u_2 \\
    \dot{u}_3 &amp;= p_7u_2-p_8u_3
\end{aligned}\]</p><p>We again can generate data to see how WENDy can estimate parameters. In this case it is realistic to for there to be LogNormal measurement error, so we choose this to be the distribution of the noise.</p><pre><code class="language-julia hljs">## Define rhs, ic, time domain, and length of parameters
function f!(du, u, p, t)
    du[1] = p[1] / (2.15 + p[3] * u[3]^p[4]) - p[2] * u[1]
    du[2] = p[5]*u[1]- p[6]*u[2]
    du[3] = p[7]*u[2]-p[8]*u[3]
    nothing
end
tRng  = (0.0, 80.0)
dt    = 0.5
u₀    = [0.3617, 0.9137, 1.3934]
pstar = [3.4884, 0.0969, 1.0, 10, 0.0969, 0.0581, 0.0969, 0.0775]
J     = length(pstar)
D     = length(u₀)

ode = ODEProblem(
    f!,
    u₀,
    tRng,
    pstar
)
tt    = tRng[1]:dt:tRng[end]
Mp1   = length(tt)
Ustar = reduce(vcat, um&#39; for um in solve_ode(ode, saveat=dt).u)
nr   = 0.05
U     = Ustar .* exp.(nr*randn(size(Ustar))) # LogNormal Noise</code></pre><p>Now we are ready to build the WENDy Problem and solve it for the unknown parameters. In this case, it is important to update the default hyper-parameters for the test function radii. In general, pick values for the test function radii that are larger than the step size, and smaller than the whole domain. In this case, the maximum test function radius is too small.  </p><pre><code class="language-julia hljs">params = WENDyParameters(
    radiusMinTime=dt,
    radiusMaxTime=tRng[end]/5
); # be sure to set the min and max testFunction radii to something reasonable
wendyProb = WENDyProblem(
    tt,
    U,
    f!,
    J;
    noiseDist=Val(LogNormal), # multiplicative LogNormal noise
    params=params,
);
J = length(pstar)</code></pre><p>Here we are perturbing slightly from the true values for the initial guess. In practice one would provide this without knowledge of the true parameters. </p><pre><code class="language-julia hljs">p₀ =  [3.0, 0.1, 4, 12, 0.1, 0.1, 0.1, 0.1]
phat = solve(wendyProb, p₀)</code></pre><p>We can visualize the quality of our estimated parameters by forward simulating and then plotting. </p><pre><code class="language-julia hljs">odeprob = ODEProblem(f!, u₀, tRng, phat)
sol = solve_ode(odeprob; saveat=dt)
Uhat = reduce(vcat, um&#39; for um in sol.u)
colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
plot(
    reduce(vcat, [
        scatter(x=tt, y=U[:,d], marker_color=colors[d], name=&quot;data&quot;, mode=&quot;markers&quot;, legendgroup=d, marker_opacity=0.5),
        scatter(x=tt, y=Uhat[:,d],line_color=colors[d], line_dash=&quot;dash&quot;, name=&quot;estimate&quot;, legendgroup=d, legendgrouptitle_text=&quot;u[$d]&quot;),
        scatter(x=tt, y=Ustar[:,d],line_color=colors[d], name=&quot;truth&quot;, legendgroup=d )
    ] for d in 1:D),
    Layout(title=&quot;Goodwin Example&quot;,xaxis_title=&quot;time(s)&quot;, yaxis_title=&quot;State&quot;)
)</code></pre><img src="406967b7.svg" alt="Example block output"/><h2 id="SIR"><a class="docs-heading-anchor" href="#SIR">SIR</a><a id="SIR-1"></a><a class="docs-heading-anchor-permalink" href="#SIR" title="Permalink"></a></h2><p>The susceptible-infected-recovered (SIR) model is pervasive in epidemiology. This system describes an extension that allows for time delayed immunity (TDI) for parasitic deceases where there is a common source for infection.</p><p class="math-container">\[\begin{aligned}
    \dot{u}_{1} &amp;= -p_{1}  u_{1} + p_{3}  u_{2} + \tfrac{p_1 e^{-p_1  p_2}}{1 - e^{-p_1  p_2}} u_{3} \\
    \dot{u}_{2} &amp;= p_{1}  u_{1} - p_{3}  u_{2} \\
    &amp; - p_{4}  (1 - e^{-p_{5}  t^2})  u_{2} \\
    \dot{u}_{3} &amp;= p_{4}  (1 - e^{-p_{5}  t^2})  u_{2} - \tfrac{p_1 e^{-p_1  p_2}}{1 - e^{-p_1  p_2}}  u_{3}
\end{aligned}\]</p><p>Again we can build test data by first simulating with true parameters, and then corrupting with multiplicative LogNormal noise.</p><pre><code class="language-julia hljs">## Define rhs, ic, time domain, and length of parameters
function f!(du, u, p, t)
    β = (p[1] * exp(-p[1] * p[2])) / (1 - exp(-p[1] * p[2]))
    du[1] = -p[1] * u[1] + p[3] * u[2] + β * u[3]
    du[2] = p[1] * u[1] - p[3] * u[2] - p[4] * (1 - exp(-p[5]  * t^2)) * u[2]
    du[3] = p[4] * (1 - exp(-p[5]  * t^2)) * u[2] - β * u[3]
end
tRng  = (0.0, 50.0)
dt    = 0.1
u₀    = [1,0,0]
pstar = [0.2,1.5,0.074,0.113,0.0024]
J     = length(pstar)
D     = length(u₀)
## Generate data (one could use empircal data in practice)
ode = ODEProblem(
    f!,
    u₀,
    tRng,
    pstar
)
tt    = tRng[1]:dt:tRng[end]
Mp1   = length(tt)
Ustar = reduce(vcat, um&#39; for um in solve_ode(ode, saveat=dt).u)
nr   = 0.1
U     = Ustar .* exp.(nr*randn(size(Ustar)))</code></pre><p>The time domain <code>[0,50]</code> so in this case it is best to adjust the parameters for the radii of the test functions. Also, we can define constraints for the parameters considered in optimization.</p><pre><code class="language-julia hljs">params = WENDyParameters(
    radiusMinTime  = 0.1,
    radiusMaxTime  = 25.0
)
constraints = [
    (1e-4,1.0),
    (1e-4,2.0),
    (1e-4,1.0),
    (1e-4,1.0),
    (1e-4,1.0),
]
wendyProb = WENDyProblem(
    tt,
    U,
    f!,
    J;
    noiseDist=Val(LogNormal), # LogNormalNoise
    params=params,
    constraints=constraints
)</code></pre><p>In this case we can perturb from truth as an example initial guess for the parameters. In practice, this guess would not be made from prior information of the true parameters.  </p><pre><code class="language-julia hljs">p₀ = pstar + 0.5*randn(J).*abs.(pstar)
phat = solve(wendyProb, p₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 0.2008453994639545
 1.4980735372473784
 0.07496567472526462
 0.11283924761904976
 0.0024065595213539864</code></pre><p>We can visualize the quality of our estimated parameters by forward simulating and then plotting. </p><pre><code class="language-julia hljs">odeprob = ODEProblem(f!, u₀, tRng, phat)
sol = solve_ode(odeprob; saveat=dt)
Uhat = reduce(vcat, um&#39; for um in sol.u)
colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
plot(
    reduce(vcat, [
        scatter(x=tt, y=U[:,d], marker_color=colors[d], name=&quot;data&quot;, mode=&quot;markers&quot;, legendgroup=d, marker_opacity=0.5 ),
        scatter(x=tt, y=Uhat[:,d],line_color=colors[d], line_dash=&quot;dash&quot;, name=&quot;estimate&quot;, legendgroup=d, legendgrouptitle_text=&quot;u[$d]&quot;),
        scatter(x=tt, y=Ustar[:,d],line_color=colors[d], name=&quot;truth&quot;, legendgroup=d )
    ] for d in 1:D),
    Layout(title=&quot;SIR&quot;,xaxis_title=&quot;time(s)&quot;, yaxis_title=&quot;State&quot;)
)</code></pre><img src="704f0038.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gettingStarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 01:15">Thursday 4 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
