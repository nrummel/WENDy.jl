var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [WENDy]\nPrivate = false\nOrder=[:function, :type]","category":"page"},{"location":"reference/#WENDy.solve","page":"Reference","title":"WENDy.solve","text":"Solve the inverse problem for the unknown parameters     solve(         wendyProb::WENDyProblem,          p₀::AbstractVector{<:Real},         params::WENDyParameters=WENDyParameters();          alg::Symbol=:trustRegion,          kwargs...     )\n\nArguments\n\nwendyProblem::WENDyProblem : An instance of a WENDyProblem for the ODE that you wish to estimate parameters for \np₀::AbstractVector{<:Real} : Inital guess for the parameters\nparams::WENDyParameters : hyperparameters for the WENDy Algorithm \nalg::AbstractWENDySolver=TrustRegion() : Choice of solver \nOELS : output error least squares\nWLS : weak form least squares \nIRLS : WENDy generalized least squares solver via iterative reweighted least squares \nTrustRegion : (default) optimize over the weak form negative log-likelihood with a trust region solver. This approximates the maximum likelhood estimator. Note: this is the only solver that will respect the constraints\nARCqK : optimize over the weak form negative log-likelihood with adaptive regularized cubics algorithm\nHybridTrustRegionOELS : hybrid solver that first optimizes with the trust region solver then passes the result as an intialization to the output error least squares problem\nHybridWLSTrustRegion : hybrid solver that first optimizes with the weak form least squares solver then passes the result as an intialization to the trust region weak form negative log-likelihood solver\n\n\n\n\n\n","category":"function"},{"location":"reference/#WENDy.WENDyParameters","page":"Reference","title":"WENDy.WENDyParameters","text":"Hyper-parameters for the WENDy Algorithm\n\nConstructor\n\nWENDyParameters(;   \n    diagReg::Real=1.0e-10,\n    radiusMinTime::Real=0.01,\n    radiusMaxTime::Real=5.0,\n    numRadii::Int=100,\n    radiiParams::AbstractVector{<:Real}=2 .^(0:3),\n    testFunSubRate::Real=2.0,\n    maxTestFunCondNum::Real=1e4,\n    minTestFunInfoNum::Real=0.95,\n    Kmax::Int=200,\n    Kᵣ::Union{Nothing,Int}=100,\n    fsAbstol::Real=1e-8,\n    fsReltol::Real=1e-8,\n    nlsAbstol::Real=1e-8,\n    nlsReltol::Real=1e-8,\n    nlsMaxiters::Int=1000,\n    optimAbstol::Real=1e-8,\n    optimReltol::Real=1e-8,\n    optimMaxiters::Int=500,\n    optimTimelimit::Real=200.0,\n    fsAlg::OrdinaryDiffEqAlgorithm=Rodas4P(),\n    fsU0Free::Bool=true\n)\n\nFields\n\ndiagReg::Real = 1.0e-10 : Regularization constant for the covariance computations\nradiusMinTime::Real = 0.01 : Minimum test function radius (in time units matching _tt)\nradiusMaxTime::Real = 5.0 : Minimum test function radius (in time units matching _tt)\nnumRadii::Int = 100 : Maximum number of radii to be checked in the min radii detection sub-algorithm\nradiiParams::AbstractVector{<:Real} = 2 .^(0:3) : Multiplied by the minRadius to give a list of radii to use when building the test function  matrix\ntestFunSubRate::Real = 2.0 : Corresponds to how much we should sup-sample in the min radii detection sub-algorithm \nmaxTestFunCondNum::Real = 1e4 : Maximum Condition number of the test function matrix after svd reduction\nminTestFunInfoNum::Real = 0.95 : Minimum information (σₖ/σ₁)in the test function matrix after svd reduction\nKmax::Int = 200 : Hard maximum size on the test function matrix\nKᵣ::Union{Nothing,Int} = 100 : how many test function to spread through the time domain in the min radii detection sub-algorithm\nfsAbstol::Real = 1e-8 : forward solve absolute tolerance for solving ordinary differential equation\nfsReltol::Real = 1e-8 : forward solve relative tolerance for solving ordinary differntial equation\nnlsAbstol::Real = 1e-8 : nonlinear least squares absolute tolerance (only used in the IRLS WENDy algorithm)\nnlsReltol::Real = 1e-8 : nonlinear least squares relative tolerance (only used in the IRLS WENDy algorithm)\nnlsMaxiters::Int = 1000 : nonlinear least squares maximum iterations (only used in the IRLS WENDy algorithm)\noptimAbstol::Real = 1e-8 : absolute tolerance (used by all other optimization algorithms)\noptimReltol::Real = 1e-8 : relative tolerance (used by all other optimization algorithms)\noptimMaxiters::Int = 200 : maximum iterations (used by all other optimization algorithms)\noptimTimelimit::Real = 500.0 : maximum time in seconds (used by all other optimization algorithms)\nfsAlg::OrdinaryDiffEqAlgorithm = Rodas4P() :  forward solve algorithm used by the forward solve nonlinear least squares algorithm\nfsU0Free::Bool = true : Specifies if the forward solve algorithm should also optimize over the initial condition\n\n\n\n\n\n","category":"type"},{"location":"reference/#WENDy.WENDyProblem","page":"Reference","title":"WENDy.WENDyProblem","text":"WENDyProblem{lip, DistType}(...)\n\nA WENDyProblem struct pre-computes and allocates data structures for efficient solving of the parameter inverse problem\n\nConstructor\n\nWENDyProblem(\n    _tt::AbstractVector{<:Real}, \n    U::AbstractVecOrMat{<:Real}, \n    _f!::Function, \n    J::Int, \n    ::Val{lip}=Val(false), \n    ::Val{DistType}=Val(Normal), \n    params::WENDyParameters=WENDyParameters(); \n    constraints::Union{Nothing,AbstractVector{Tuple{<:Real,<:Real}}}=nothing, \n    ll::LogLevel=Warn\n)\n\nArguments\n\n_tt::AbstractVector{<:Real} : vector of times (equispaced)\nU::AbstractVecOrMat{<:Real} : Corrupted state variable data \n_f!::Function : Right hand-side of the differential equation\nJ::Int : number of parameters (to be estimated)\n::Val{lip}=Val(false) : (optional) specify whether the right hand side is `linear in parameters' for improved computational efficiency\n::Val{DistType}=Val(Normal) : (optional) specify the distribution of the measurement noise. Choose either Val(Normal) for additive Gaussian noise of Val(LogNormal) for multiplicative LogNormal noise.\nparams::WENDyParameters : (optional) struct of hyper-parameters for the WENDy Algorithm (see the doc for WENDyParameters)\nconstraints=nothing : (optional) Linear box constraints for each parameter, ∀j ∈ [1, ⋯,J], ℓⱼ ≤ pⱼ ≤ uⱼ. Accepts constraints as a list of tuples, [(ℓ₁,u₁), ⋯]. Note: this only is compatible with the TrustRegion solver.\nll::LogLevel=Warn : (optional) see additional algorithm information by setting ll=Info\n\nFields\n\nD::Int : number of state variables\nJ::Int : number of parameters (to be estimated)\nMp1::Int : (Mp1+1) number of data points in time \nK::Int : number of test functions \nu₀::AbstractVector{<:Real} : Initial Condition of the ODE (Necessary for the forward solver)\nconstraints : vector of tuples containing linear constraints for each parameter\ndata : Internal data structure \noels::LeastSquaresCostFunction : Cost function for the comparison method\nwlsq::LeastSquaresCostFunction : Cost function for the weak form least squares problem\nwnll::SecondOrderCostFunction : Cost function for the weak form negative log-likelihood \n\n\n\n\n\n","category":"type"},{"location":"#WENDy.jl-Weak-Form-Estimation-of-Nonlinear-Dynamics","page":"Home","title":"WENDy.jl - Weak Form Estimation of Nonlinear Dynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of WENDy.jl. The work comes from the the MathBio Group at University of Colorado Boulder. For further reading find our paper at arxiv link.","category":"page"},{"location":"#Problem-Statement","page":"Home","title":"Problem Statement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WENDy is an algorithm that can estimate unknown parameters for ordinary differential equations given noisy data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The set up for this algorithm is to assume that a physical system with state variable, boldsymbolu in mathbbR^D, is governed by a system of ordinary differential equation with true parameters, mathbfp^* in mathbbR^J:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    dotboldsymbolu(t) = f(boldsymbolu(t) t mathbfp^*)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user has observed data of this system on a uniform grid, t_m mathbfu_m_m=0^M. The data has been corrupted by noise:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additive Gaussian Case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginalign*\n        mathbfu_m = boldsymbolu(t_m p^*) + epsilon_m _m=0^M \n        epsilon_m stackreliidsim mathcalN(mathbf0 mathbbI_D)\n    endalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiplicative LogNormal Case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginalign*\n        mathbfu_m = boldsymbolu(t_m p^*) circ eta_m _m=0^M \n        log(eta) stackreliidsim mathcalN(mathbf0 mathbbI_D)\n    endalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: The Hadamard product circ is the element-wise multiplication on the two vectors. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal of the algorithm is that recover unknown parameters mathbfp. In other words, we hope that if the one were to solve the system of differential equations with the estimated parameters then it would match the true state, then ","category":"page"},{"location":"","page":"Home","title":"Home","text":"    frac boldsymbolu(t mathbfp) - boldsymbolu(t mathbfp^*)boldsymbolu(t mathbfp^*) ll 1 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is done by leveraging a estimated distribution of the weak form residual, mathbfr, and then approximating a maximum likelihood estimate: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"    mathbfS(mathbfp)^-tfrac12 mathbfr(mathbfp) sim mathcalN(0 mathbbI)","category":"page"},{"location":"#Current-features","page":"Home","title":"Current features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Estimation of parameters for ordinary differential equations\nSupports: \nAdditive Gaussian Noise and Multiplicative LogNormal Noise.\nOrdinary differential equations that are nonlinear in parameters\nOrdinary differential equations that are inhomogeneous \nBox constraints for parameter spaces\nProvides acceleration for problems that are linear in parameters \nDirectly calls robust optimization algorithms that are well suited to an non-convex problems.\nCreates efficient Julia functions for the likelihood function and its derivatives with minimal inputs from the end user.","category":"page"}]
}
