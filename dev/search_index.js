var documenterSearchIndex = {"docs":
[{"location":"examples/","page":"Examples","title":"Examples","text":"Here we give three examples of ODE's and how to use WENDy to estimate the parameters. ","category":"page"},{"location":"examples/#Logistic-Growth","page":"Examples","title":"Logistic Growth","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The logistic growth equation is a well-known differential equation that has an exact solution. Classically, it was developed to describe population growth rate r with a carrying capacity K, dotu = ru(1-tfracuK). We have reparameterized this equation to be amenable to optimization. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"dotu=p_1 u+p_2 u^2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the sake of the example we will generate data by numerically solving the ODE, and then corrupting with noise. We do this through the standard library and OrdinaryDiffEq.jl. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Random, LinearAlgebra\nusing OrdinaryDiffEq: ODEProblem\nusing OrdinaryDiffEq: solve as solve_ode\nusing WENDy","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we define the right hand side of the ODE, initial conditions, the time domain, and specify the true parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function f!(du, u, p, t)\n    du[1] = p[1] * u[1] - p[2] * u[1]^2\n    nothing\nend\ntRng = (0.0, 10.0)\ndt = 0.01\nu₀ = [0.01]\npstar = [1.0, 1.0]\nJ = length(pstar)\n\node = ODEProblem(\n    f!, \n    u₀, \n    tRng, \n    pstar\n)\ntt = tRng[1]:dt:tRng[end]\nUstar = reduce(vcat, um for um in solve_ode(ode, saveat=dt).u)\nnr = 0.1 # noise ratio\nU = Ustar + nr*randn(size(Ustar)) # corrupting the data with noise\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, that we have the data we are ready to build a WENDy Problem and then solve it. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wendyProb = WENDyProblem(\n    tt, \n    U, \n    f!, \n    J\n)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The algorithm requires an initial guess for the parameter values. From this initial guess, it will then approximate the maximum likelihood estimator.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p₀ = [0.5, 0.5]\n@time phat = solve(wendyProb, p₀)\n@show phat \nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The efficiency of the solver can be improved by specifying that the function f is linear in parameters. This is done with the optional argument to the WENDyProblem. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wendyProb_linear = WENDyProblem(\n    tt, \n    U, \n    f!, \n    J, \n    linearInParameters=Val(true), # f! is linear in parameters \n)\n@time (wendyProb_linear, p₀)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This problem can be visualized by looking at the data, the true solution of the ODE and the solution given by the estimated parameters.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PlotlyJS\nodeprob = ODEProblem(f!, u₀, tRng, phat)\nsol = solve_ode(odeprob; saveat=dt)\nUhat = reduce(vcat, um' for um in sol.u)\nplot(\n    [\n        scatter(x=tt, y=U[:], name=\"data\", mode=\"markers\", marker_color=\"blue\", marker_opacity=0.5),\n        scatter(x=tt, y=Ustar[:], name=\"truth\", line_color=\"blue\", line_width=3),\n        scatter(x=tt, y=Uhat[:], name=\"estimate\", line_dash=\"dash\", line_color=\"black\", line_width=3),\n    ],\n    Layout(title=\"Logistic Growth\",xaxis_title=\"time(s)\", yaxis_title=\"u(t)\")\n)","category":"page"},{"location":"examples/#Goodwin","page":"Examples","title":"Goodwin","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of a system of differential equations which is nonlinear in parameters is the Goodwin model which describes negative feedback control processes . In particular there is a Hill function in the equation for u_1. The parameter p_3 appears in the denominator and p_4 is the Hill coefficient, and thus this serves as an example of how nonlinearity can effect the performance of the WENDy algorithm. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n    dotu_1 = fracp_1215 + p_3 u_3^p_4 - p_2  u_1 \n    dotu_2 = p_5u_1- p_6u_2 \n    dotu_3 = p_7u_2-p_8u_3\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We again can generate data to see how WENDy can estimate parameters. In this case it is realistic to for there to be LogNormal measurement error, so we choose this to be the distribution of the noise.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Random, Logging, LinearAlgebra # hide\nusing PlotlyJS # hide\nusing WENDy # hide\nusing OrdinaryDiffEq: ODEProblem # hide\nusing OrdinaryDiffEq: solve as solve_ode # hide\n## Define rhs, ic, time domain, and length of parameters\nfunction f!(du, u, p, t)\n    du[1] = p[1] / (2.15 + p[3] * u[3]^p[4]) - p[2] * u[1]\n    du[2] = p[5]*u[1]- p[6]*u[2]\n    du[3] = p[7]*u[2]-p[8]*u[3]\n    nothing\nend\ntRng  = (0.0, 80.0)\ndt    = 0.5\nu₀    = [0.3617, 0.9137, 1.3934]\npstar = [3.4884, 0.0969, 1.0, 10, 0.0969, 0.0581, 0.0969, 0.0775]\nJ     = length(pstar)\nD     = length(u₀)\n\node = ODEProblem(\n    f!, \n    u₀, \n    tRng, \n    pstar\n)\ntt    = tRng[1]:dt:tRng[end]\nMp1   = length(tt)\nUstar = reduce(vcat, um' for um in solve_ode(ode, saveat=dt).u)\nnr   = 0.05\nU     = Ustar .* exp.(nr*randn(size(Ustar))) # LogNormal Noise\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we are ready to build the WENDy Problem and solve it for the unknown parameters. In this case, it is important to update the default hyper-parameters for the test function radii. In general, pick values for the test function radii that are larger than the step size, and smaller than the whole domain. In this case, the maximum test function radius is too small.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = WENDyParameters(\n    radiusMinTime=dt, \n    radiusMaxTime=tRng[end]/5\n); # be sure to set the min and max testFunction radii to something reasonable\nwendyProb = WENDyProblem(\n    tt, \n    U, \n    f!, \n    J;\n    noiseDist=Val(LogNormal), # multiplicative LogNormal noise\n    params=params, \n);\nJ = length(pstar)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we are perturbing slightly from the true values for the initial guess. In practice one would provide this without knowledge of the true parameters. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p₀ =  [3.0, 0.1, 4, 12, 0.1, 0.1, 0.1, 0.1]\nphat = solve(wendyProb, p₀)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the quality of our estimated parameters by forward simulating and then plotting. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = ODEProblem(f!, u₀, tRng, phat)\nsol = solve_ode(odeprob; saveat=dt)\nUhat = reduce(vcat, um' for um in sol.u)\ncolors = [\"red\", \"blue\", \"green\"]\nplot(\n    reduce(vcat, [\n        scatter(x=tt, y=U[:,d], marker_color=colors[d], name=\"data\", mode=\"markers\", legendgroup=d, marker_opacity=0.5),\n        scatter(x=tt, y=Uhat[:,d],line_color=colors[d], line_dash=\"dash\", name=\"estimate\", legendgroup=d, legendgrouptitle_text=\"u[$d]\"),\n        scatter(x=tt, y=Ustar[:,d],line_color=colors[d], name=\"truth\", legendgroup=d )\n    ] for d in 1:D),\n    Layout(title=\"Goodwin Example\",xaxis_title=\"time(s)\", yaxis_title=\"State\")\n)","category":"page"},{"location":"examples/#SIR","page":"Examples","title":"SIR","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The susceptible-infected-recovered (SIR) model is pervasive in epidemiology. This system describes an extension that allows for time delayed immunity (TDI) for parasitic deceases where there is a common source for infection.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n    dotu_1 = -p_1  u_1 + p_3  u_2 + tfracp_1 e^-p_1  p_21 - e^-p_1  p_2 u_3 \n    dotu_2 = p_1  u_1 - p_3  u_2 \n     - p_4  (1 - e^-p_5  t^2)  u_2 \n    dotu_3 = p_4  (1 - e^-p_5  t^2)  u_2 - tfracp_1 e^-p_1  p_21 - e^-p_1  p_2  u_3\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Again we can build test data by first simulating with true parameters, and then corrupting with multiplicative LogNormal noise.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Random, Logging, LinearAlgebra # hide\nusing PlotlyJS # hide\nusing WENDy # hide\nusing OrdinaryDiffEq: ODEProblem # hide\nusing OrdinaryDiffEq: solve as solve_ode # hide\n## Define rhs, ic, time domain, and length of parameters\nfunction f!(du, u, p, t)\n    β = (p[1] * exp(-p[1] * p[2])) / (1 - exp(-p[1] * p[2]))\n    du[1] = -p[1] * u[1] + p[3] * u[2] + β * u[3] \n    du[2] = p[1] * u[1] - p[3] * u[2] - p[4] * (1 - exp(-p[5]  * t^2)) * u[2] \n    du[3] = p[4] * (1 - exp(-p[5]  * t^2)) * u[2] - β * u[3]\nend\ntRng  = (0.0, 50.0)\ndt    = 0.1\nu₀    = [1,0,0]\npstar = [0.2,1.5,0.074,0.113,0.0024]\nJ     = length(pstar)\nD     = length(u₀)\n## Generate data (one could use empircal data in practice)\node = ODEProblem(\n    f!, \n    u₀, \n    tRng, \n    pstar\n)\ntt    = tRng[1]:dt:tRng[end]\nMp1   = length(tt)\nUstar = reduce(vcat, um' for um in solve_ode(ode, saveat=dt).u)\nnr   = 0.1\nU     = Ustar .* exp.(nr*randn(size(Ustar)))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The time domain [0,50] so in this case it is best to adjust the parameters for the radii of the test functions. Also, we can define constraints for the parameters considered in optimization.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = WENDyParameters(\n    radiusMinTime  = 0.1,\n    radiusMaxTime  = 25.0\n)\nconstraints = [\n    (1e-4,1.0), \n    (1e-4,2.0),\n    (1e-4,1.0),\n    (1e-4,1.0),\n    (1e-4,1.0),\n]\nwendyProb = WENDyProblem(\n    tt, \n    U, \n    f!, \n    J;\n    noiseDist=Val(LogNormal), # LogNormalNoise\n    params=params,\n    constraints=constraints\n)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case we can perturb from truth as an example initial guess for the parameters. In practice, this guess would not be made from prior information of the true parameters.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p₀ = pstar + 0.5*randn(J).*abs.(pstar) \nphat = solve(wendyProb, p₀)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the quality of our estimated parameters by forward simulating and then plotting. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = ODEProblem(f!, u₀, tRng, phat)\nsol = solve_ode(odeprob; saveat=dt)\nUhat = reduce(vcat, um' for um in sol.u)\ncolors = [\"red\", \"blue\", \"green\"]\nplot(\n    reduce(vcat, [\n        scatter(x=tt, y=U[:,d], marker_color=colors[d], name=\"data\", mode=\"markers\", legendgroup=d, marker_opacity=0.5 ),\n        scatter(x=tt, y=Uhat[:,d],line_color=colors[d], line_dash=\"dash\", name=\"estimate\", legendgroup=d, legendgrouptitle_text=\"u[$d]\"),\n        scatter(x=tt, y=Ustar[:,d],line_color=colors[d], name=\"truth\", legendgroup=d )\n    ] for d in 1:D),\n    Layout(title=\"SIR\",xaxis_title=\"time(s)\", yaxis_title=\"State\")\n)","category":"page"},{"location":"reference/#WENDy.solve","page":"Reference","title":"WENDy.solve","text":"Solve the inverse problem for the unknown parameters     solve(         wendyProb::WENDyProblem,          p₀::AbstractVector{<:Real},         params::WENDyParameters=WENDyParameters();          alg::Symbol=:trustRegion,          kwargs...     )\n\nArguments\n\nwendyProblem::WENDyProblem : An instance of a WENDyProblem for the ODE that you wish to estimate parameters for \np₀::AbstractVector{<:Real} : Inital guess for the parameters\nparams::WENDyParameters : hyperparameters for the WENDy Algorithm \nalg::AbstractWENDySolver=TrustRegion() : (optional) Choice of solver \nOELS : output error least squares\nWLS : weak form least squares \nIRLS : WENDy generalized least squares solver via iterative reweighted least squares \nTrustRegion : (default) optimize over the weak form negative log-likelihood with a trust region solver. This approximates the maximum likelhood estimator. Note: this is the only solver that will respect the constraints\nARCqK : optimize over the weak form negative log-likelihood with adaptive regularized cubics algorithm\nHybridTrustRegionOELS : hybrid solver that first optimizes with the trust region solver then passes the result as an intialization to the output error least squares problem\nHybridWLSTrustRegion : hybrid solver that first optimizes with the weak form least squares solver then passes the result as an intialization to the trust region weak form negative log-likelihood solver\n\n\n\n\n\n","category":"function"},{"location":"reference/#WENDy.WENDyParameters","page":"Reference","title":"WENDy.WENDyParameters","text":"Hyper-parameters for the WENDy Algorithm\n\nConstructor\n\nWENDyParameters(;   \n    diagReg::Real=1.0e-10,\n    radiusMinTime::Real=0.01,\n    radiusMaxTime::Real=5.0,\n    numRadii::Int=100,\n    radiiParams::AbstractVector{<:Real}=2 .^(0:3),\n    testFunSubRate::Real=2.0,\n    maxTestFunCondNum::Real=1e4,\n    minTestFunInfoNum::Real=0.95,\n    Kmax::Int=200,\n    Kᵣ::Union{Nothing,Int}=100,\n    fsAbstol::Real=1e-8,\n    fsReltol::Real=1e-8,\n    nlsAbstol::Real=1e-8,\n    nlsReltol::Real=1e-8,\n    nlsMaxiters::Int=1000,\n    optimAbstol::Real=1e-8,\n    optimReltol::Real=1e-8,\n    optimMaxiters::Int=500,\n    optimTimelimit::Real=200.0,\n    fsAlg::OrdinaryDiffEqAlgorithm=Rodas4P(),\n    fsU0Free::Bool=true\n)\n\nFields\n\ndiagReg::Real = 1.0e-10 : Regularization constant for the covariance computations\nradiusMinTime::Real = 0.01 : Minimum test function radius (in time units matching _tt)\nradiusMaxTime::Real = 5.0 : Minimum test function radius (in time units matching _tt)\nnumRadii::Int = 100 : Maximum number of radii to be checked in the min radii detection sub-algorithm\nradiiParams::AbstractVector{<:Real} = 2 .^(0:3) : Multiplied by the minRadius to give a list of radii to use when building the test function  matrix\ntestFunSubRate::Real = 2.0 : Corresponds to how much we should sup-sample in the min radii detection sub-algorithm \nmaxTestFunCondNum::Real = 1e4 : Maximum Condition number of the test function matrix after svd reduction\nminTestFunInfoNum::Real = 0.95 : Minimum information (σₖ/σ₁)in the test function matrix after svd reduction\nKmax::Int = 200 : Hard maximum size on the test function matrix\nKᵣ::Union{Nothing,Int} = 100 : how many test function to spread through the time domain in the min radii detection sub-algorithm\nfsAbstol::Real = 1e-8 : forward solve absolute tolerance for solving ordinary differential equation\nfsReltol::Real = 1e-8 : forward solve relative tolerance for solving ordinary differntial equation\nnlsAbstol::Real = 1e-8 : nonlinear least squares absolute tolerance (only used in the IRLS WENDy algorithm)\nnlsReltol::Real = 1e-8 : nonlinear least squares relative tolerance (only used in the IRLS WENDy algorithm)\nnlsMaxiters::Int = 1000 : nonlinear least squares maximum iterations (only used in the IRLS WENDy algorithm)\noptimAbstol::Real = 1e-8 : absolute tolerance (used by all other optimization algorithms)\noptimReltol::Real = 1e-8 : relative tolerance (used by all other optimization algorithms)\noptimMaxiters::Int = 200 : maximum iterations (used by all other optimization algorithms)\noptimTimelimit::Real = 500.0 : maximum time in seconds (used by all other optimization algorithms)\nfsAlg::OrdinaryDiffEqAlgorithm = Rodas4P() :  forward solve algorithm used by the forward solve nonlinear least squares algorithm\nfsU0Free::Bool = true : Specifies if the forward solve algorithm should also optimize over the initial condition\n\n\n\n\n\n","category":"type"},{"location":"reference/#WENDy.WENDyProblem","page":"Reference","title":"WENDy.WENDyProblem","text":"WENDyProblem{lip, DistType}(...)\n\nA WENDyProblem struct pre-computes and allocates data structures for efficient solving of the parameter inverse problem\n\nConstructor\n\nWENDyProblem(\n    _tt::AbstractVector{<:Real}, \n    U::AbstractVecOrMat{<:Real}, \n    _f!::Function, \n    J::Int; \n    linearInParameters::Val{lip}=Val(false), \n    noiseDist::Val{DistType}=Val(Normal), \n    params::WENDyParameters=WENDyParameters(), \n    constraints::Union{Nothing,AbstractVector{Tuple{<:Real,<:Real}}}=nothing, \n    ll::LogLevel=Warn\n)\n\nArguments\n\n_tt::AbstractVector{<:Real} : vector of times (equispaced)\nU::AbstractVecOrMat{<:Real} : Corrupted state variable data \n_f!::Function : Right hand-side of the differential equation   Must be of the form f!(du, u, p, t)\nJ::Int : number of parameters (to be estimated)\nlinearInParameters::Val{lip}=Val(false) : (optional) specify whether the right hand side is `linear in parameters' for improved computational efficiency\nnoiseDist::Val{DistType}=Val(Normal) : (optional) specify the distribution of the measurement noise. Choose either Val(Normal) for additive Gaussian noise of Val(LogNormal) for multiplicative LogNormal noise.\nparams::WENDyParameters : (optional) struct of hyper-parameters for the WENDy Algorithm (see the doc for WENDyParameters)\nconstraints=nothing : (optional) Linear box constraints for each parameter, ∀j ∈ [1, ⋯,J], ℓⱼ ≤ pⱼ ≤ uⱼ. Accepts constraints as a list of tuples, [(ℓ₁,u₁), ⋯]. Note: this only is compatible with the TrustRegion solver.\nll::LogLevel=Warn : (optional) see additional algorithm information by setting ll=Info\n\nFields\n\nD::Int : number of state variables\nJ::Int : number of parameters (to be estimated)\nMp1::Int : (Mp1+1) number of data points in time \nK::Int : number of test functions \nu₀::AbstractVector{<:Real} : Initial Condition of the ODE (Necessary for the forward solver)\nconstraints : vector of tuples containing linear constraints for each parameter\ndata : Internal data structure \noels::LeastSquaresCostFunction : Cost function for the comparison method\nwlsq::LeastSquaresCostFunction : Cost function for the weak form least squares problem\nwnll::SecondOrderCostFunction : Cost function for the weak form negative log-likelihood \n\n\n\n\n\n","category":"type"},{"location":"#WENDy.jl-Weak-Form-Estimation-of-Nonlinear-Dynamics","page":"Home","title":"WENDy.jl - Weak Form Estimation of Nonlinear Dynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of WENDy.jl. The work comes from the the Applied Math Department at University of Colorado Boulder. For further reading read our paper, WENDy for Nonlinear-in-Parameter ODEs.","category":"page"},{"location":"#Current-features","page":"Home","title":"Current features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Estimation of parameters for ordinary differential equations\nSupports: \nAdditive Gaussian Noise and Multiplicative LogNormal Noise\nOrdinary differential equations that are nonlinear in parameters\nOrdinary differential equations that are inhomogeneous in time\nBox constraints for parameter spaces\nProvides acceleration for problems that are linear in parameters \nDirectly calls robust optimization algorithms that are well suited to an non-convex problems.\nCreates efficient Julia functions for the likelihood function and its derivatives with minimal inputs from the end user.","category":"page"},{"location":"#Formal-Problem-Statement","page":"Home","title":"Formal Problem Statement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WENDy is an algorithm that can estimate unknown parameters for ordinary differential equations given noisy data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The set up for this algorithm is to assume that a physical system with state variable, boldsymbolu in mathbbR^D, is governed by a system of ordinary differential equation with true parameters, mathbfp^* in mathbbR^J:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    dotboldsymbolu(t) = f(boldsymbolu(t) t mathbfp^*)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user has observed data of this system on a uniform grid, t_m mathbfu_m_m=0^M. The data has been corrupted by noise:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additive Gaussian Case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginalign*\n        mathbfu_m = boldsymbolu(t_m p^*) + epsilon_m _m=0^M \n        epsilon_m stackreliidsim mathcalN(mathbf0 mathbbI_D)\n    endalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiplicative LogNormal Case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginalign*\n        mathbfu_m = boldsymbolu(t_m p^*) circ eta_m _m=0^M \n        log(eta) stackreliidsim mathcalN(mathbf0 mathbbI_D)\n    endalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: The Hadamard product circ is the element-wise multiplication on the two vectors. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal of the algorithm is that recover unknown parameters mathbfp. In other words, we hope that if one were to solve the system of differential equations with the estimated parameters then it would match the true state, then ","category":"page"},{"location":"","page":"Home","title":"Home","text":"    frac boldsymbolu(t mathbfp) - boldsymbolu(t mathbfp^*)boldsymbolu(t mathbfp^*) ll 1 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is done by leveraging a estimated distribution of the weak form residual, mathbfr, and then approximating a maximum likelihood estimate: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"    mathbfS(mathbfp)^-tfrac12 mathbfr(mathbfp) sim mathcalN(0 mathbbI)","category":"page"},{"location":"#Aknowledgements","page":"Home","title":"Aknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Functions for the likelihood and its derivatives are formed analytically through symbolic computations using Symbolics.jl. These functions are then used in second order optimization methods. While the likelihood is a scalar valued function, its computation relies on the derivatives of vector and matrix valued functions. Building and using efficient data structures to compute these derivative can rely on ``vectorization'' resulting large matrices with block structure from Kronecker products. In our implementation we instead use multidimensional array and define the operations in Einstein summation notation. These computations are then evaluated efficiently with Tullio.jl. Trust region solvers are provided by JSOSolvers.jl and Optim.jl for the constrained and unconstrained cases respectively. We note that our code also supports using the Adaptive Regularization Cubics variant (ARCqK) in the unconstrained case provide by AdaptiveRegularization.jl. The trust region solvers and ARCqK usually produce similar results, but in our limited testing we found the trust region solvers work better in general. ","category":"page"},{"location":"gettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The first step to using WENDy.jl is to build the WENDyProblem struct. The constructor will precompute all the necessary data and prepare all the necessary functions to run different optimizers to estimate the unknown parameters p. The algorithm only requires a few inputs ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"tt : vector of equispaced times t_m_m=0^M.\nU : data matrix where each row is a state vector at each time mathbfu_m = boldsymbolu(t_m) + epsilon_m_m=0^M. This makes the size of this matrix M+1times D. \nf! : right hand side function for the ordinary system of equations of the form f!(du, u, p, t)\nJ : An integer specifying the length of the unknown parameters vector p.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"wendyProb = WENDyProblem(tt, U, f!, J)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"It is important to note that there are optional inputs that are keyword arguments that can help get the best performance from the algorithm. ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"linearInParameters : (Default Val(false)) If the ODE is linear in parameters (lip) then one can accelerate our weak form algorithms by setting this to Val(true). This allows the WENDyProblem to be specified as lip at compile time. Specifying special routines that will make many function evaluations and the following optimization faster. \nnoiseDist : (Default Val(Normal)) This specifies whether the noise is additive Gaussian Val(Normal) or multiplicative LogNormal Val(LogNormal). Again this flag allows the correct subroutines to be specified at compile time. \nparams : (Default WENDyParameters())One can update the hyper-parameters for WENDy via the WENDyParameters struct. Of particular interest are the parameters that inform the test function selection algorithm (see Test Function Selection) and those that that inform the optimization algorithms (see Optimization Parameters)\nconstraints : (Default Nothing) WENDy supports linear box constraints for each parameter, ∀j ∈ [1, ⋯,J], ℓⱼ ≤ pⱼ ≤ uⱼ. Accepts constraints as a list of tuples, [(ℓ₁,u₁), ⋯]. Note: this only is compatible with the TrustRegion solver.\nll : (Default Warn) Logging level ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The next step is to solve the WENDy problem. This is done by calling the solve function. An initial guess for the parameters, p_0, is necessary for the local optimization routines to run. It may be necessary to run the WENDy algorithm with multiple initial guesses for best results. ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"solve(wendyProb, p₀)","category":"page"},{"location":"gettingStarted/#Test-Function-Selection","page":"Getting Started","title":"Test Function Selection","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"WENDy works by moving the system of equation into its weak form. For this purpose, we select test functions that are bump functions of the form:","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"\tvarphi(t  a)=C exp left(-fracetaleft1-(tfractm_tDelta t )^2right_+right)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"where m_t can be thought of as the radius of the support, the constant C normalizes the test function such that varphi_2=1, and eta is a shape parameter, and cdot_+ = max (cdot 0), so that varphi(t  m_tDelta t) is supported only on -m_tDelta t m_tDelta t.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"WENDy.jl attempts to automatically select multiple test functions with radii that balance preserving information while minimizing the effects due to noise. One may want to adjust the following in the WENDyParameters:","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Kmax - maximum number of test functions allow. This is a hard threshold, and may be aggressive in some cases. Set the Logging Level ll in the WENDyProblem constructor to Info. If the information lost in the SVD reduction gets below 50% then an adjustment may be necessary. In most cases, the radii of the test functions is more likely cause of poor results. \nradiusMinTime which is a lower bound on the smallest m_t considered by WENDy. This parameters has the same units as the tt passed when building a WENDyProblem. \nradiusMaxTimewhich is a upper bound on the smallest m_t considered by WENDy. This parameters has the same units as the tt passed when building a WENDyProblem. ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"A good idea is to visualize the data yourself, and see how quickly the state variable is changing. It is ok to give WENDy a large range for the test function radii, but some adjustment may be necessary to get the best results. ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The other test function parameters really get into the weeds of the this sub algorithm and in most cases are best left alone. ","category":"page"},{"location":"gettingStarted/#Optimization-Parameters","page":"Getting Started","title":"Optimization Parameters","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"WENDy makes use of several different optimization routines. For the default solver, one may want to adjust the following in the WENDyParameters for runtime or accuracy:","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"optimAbstol : (Default 1e-8) Absolute Error Tolerance\noptimReltol : (Default 1e-8) Relative Error Tolerance\noptimMaxiters : (Default 500) Maximum Number of Iterations\noptimTimelimit : (Default 200.0) Time limit in seconds","category":"page"},{"location":"gettingStarted/#Solver-Selection","page":"Getting Started","title":"Solver Selection","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"WENDy.jl allows for the user to make use of several different solvers. This is done through the keyword argument solve(wendyProblem, p₀ ; solver = ...) in the solve . ","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"For the maximum likelihood estimator one should select either:\nTrustRegion() : (Default) Allows for both constrained and unconstrained problems\nARCqK() : Only for the unconstrained, but may lead to a different solution\nOELS() : A common technique is to minimize the output error. WENDy.jl provides a simple forward solve least squares solver for comparison. \nIRLS() : This is (in general) a more computationally efficient solver that still incorporates covariance information from the weak form residual, but frames a generalized least squares problem instead of a maximum likelihood estimator. \nWLS() : This simple minimizes the norm of the weak form residual by posing either linear or nonlinear least squares problem. This is the most appropriate if there is no noise in the system. ","category":"page"}]
}
